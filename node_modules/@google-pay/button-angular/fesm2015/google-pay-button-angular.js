import { Directive, ElementRef, Input, NgModule } from '@angular/core';

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Keeps track scripts that have been requested by loadScript.
 */
let cachedScripts = {};
/**
 * Asynchronously loads a script keeping track of which scripts have already
 * requested and loaded.
 *
 * Multiple requests to the same resource will return the same promise.
 *
 * @param src Script URL to load
 */
function loadScript(src) {
    const existing = cachedScripts[src];
    if (existing) {
        return existing;
    }
    const promise = new Promise((resolve, reject) => {
        // Create script
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        // Script event listener callbacks for load and error
        const onScriptLoad = () => {
            resolve();
        };
        const onScriptError = () => {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            cleanup();
            // Remove from cachedScripts so that we can try loading again
            delete cachedScripts[src];
            script.remove();
            reject(new Error(`Unable to load script ${src}`));
        };
        script.addEventListener('load', onScriptLoad);
        script.addEventListener('error', onScriptError);
        // Add script to document body
        document.body.appendChild(script);
        // Remove event listeners on cleanup
        function cleanup() {
            script.removeEventListener('load', onScriptLoad);
            script.removeEventListener('error', onScriptError);
        }
    });
    cachedScripts[src] = promise;
    return promise;
}
/**
 * Clears the script cache. Used for testing purposes only.
 */
function clearScriptCache() {
    cachedScripts = {};
}

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Manages the lifecycle of the Google Pay button.
 *
 * Includes lifecycle management of the `PaymentsClient` instance,
 * `isReadyToPay`, `onClick`, `loadPaymentData`, and other callback methods.
 */
class ButtonManager {
    constructor(options) {
        this.handleClick = () => __awaiter(this, void 0, void 0, function* () {
            const config = this.config;
            if (!config) {
                throw new Error('google-pay-button: Missing configuration');
            }
            const request = this.createLoadPaymentDataRequest(config);
            try {
                const result = yield this.client.loadPaymentData(request);
                if (config.onLoadPaymentData) {
                    config.onLoadPaymentData(result);
                }
            }
            catch (err) {
                if (err.statusCode === 'CANCELED') {
                    if (config.onCancel) {
                        config.onCancel(err);
                    }
                }
                else if (config.onError) {
                    config.onError(err);
                }
                else {
                    console.error(err);
                }
            }
        });
        this.options = options;
    }
    getElement() {
        return this.element;
    }
    isGooglePayLoaded() {
        var _a, _b;
        return 'google' in (window || global) && !!((_b = (_a = google === null || google === void 0 ? void 0 : google.payments) === null || _a === void 0 ? void 0 : _a.api) === null || _b === void 0 ? void 0 : _b.PaymentsClient);
    }
    mount(element) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isGooglePayLoaded()) {
                yield loadScript('https://pay.google.com/gp/p/js/pay.js');
            }
            this.element = element;
            if (element) {
                this.appendStyles();
                if (this.config) {
                    this.updateElement();
                }
            }
        });
    }
    unmount() {
        this.element = undefined;
    }
    configure(newConfig) {
        this.config = newConfig;
        if (!this.oldInvalidationValues || this.isClientInvalidated(newConfig)) {
            this.updateElement();
        }
        this.oldInvalidationValues = this.getInvalidationValues(newConfig);
    }
    /**
     * Creates client configuration options based on button configuration
     * options.
     *
     * This method would normally be private but has been made public for
     * testing purposes.
     *
     * @private
     */
    createClientOptions(config) {
        const clientConfig = {
            environment: config.environment,
            merchantInfo: this.createMerchantInfo(config),
        };
        if (config.onPaymentDataChanged || config.onPaymentAuthorized) {
            clientConfig.paymentDataCallbacks = {};
            if (config.onPaymentDataChanged) {
                // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
                clientConfig.paymentDataCallbacks.onPaymentDataChanged = paymentData => {
                    const result = config.onPaymentDataChanged(paymentData);
                    return result || {};
                };
            }
            if (config.onPaymentAuthorized) {
                // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
                clientConfig.paymentDataCallbacks.onPaymentAuthorized = paymentData => {
                    const result = config.onPaymentAuthorized(paymentData);
                    return result || {};
                };
            }
        }
        return clientConfig;
    }
    createIsReadyToPayRequest(config) {
        const paymentRequest = config.paymentRequest;
        const request = {
            apiVersion: paymentRequest.apiVersion,
            apiVersionMinor: paymentRequest.apiVersionMinor,
            allowedPaymentMethods: paymentRequest.allowedPaymentMethods,
            existingPaymentMethodRequired: config.existingPaymentMethodRequired,
        };
        return request;
    }
    /**
     * Constructs `loadPaymentData` request object based on button configuration.
     *
     * It infers request properties like `shippingAddressRequired`,
     * `shippingOptionRequired`, and `billingAddressRequired` if not already set
     * based on the presence of their associated options and parameters. It also
     * infers `callbackIntents` based on the callback methods defined in button
     * configuration.
     *
     * This method would normally be private but has been made public for
     * testing purposes.
     *
     * @private
     */
    createLoadPaymentDataRequest(config) {
        const request = Object.assign(Object.assign({}, config.paymentRequest), { merchantInfo: this.createMerchantInfo(config) });
        // TODO: #13 re-enable inferrence if/when we agree as a team
        return request;
    }
    createMerchantInfo(config) {
        const merchantInfo = Object.assign({}, config.paymentRequest.merchantInfo);
        // apply softwareInfo if not set
        if (!merchantInfo.softwareInfo) {
            merchantInfo.softwareInfo = {
                id: this.options.softwareInfoId,
                version: this.options.softwareInfoVersion,
            };
        }
        return merchantInfo;
    }
    isMounted() {
        return this.element != null && this.element.isConnected !== false;
    }
    removeButton() {
        if (this.element instanceof ShadowRoot || this.element instanceof Element) {
            for (const child of Array.from(this.element.children)) {
                if (child.tagName !== 'STYLE') {
                    child.remove();
                }
            }
        }
    }
    updateElement() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isMounted())
                return;
            const element = this.element;
            if (!this.config) {
                throw new Error('google-pay-button: Missing configuration');
            }
            // remove existing button
            this.removeButton();
            this.client = new google.payments.api.PaymentsClient(this.createClientOptions(this.config));
            const buttonOptions = {
                buttonType: this.config.buttonType,
                buttonColor: this.config.buttonColor,
                buttonSizeMode: this.config.buttonSizeMode,
                onClick: this.handleClick,
            };
            const rootNode = (_a = this.element) === null || _a === void 0 ? void 0 : _a.getRootNode();
            if (rootNode instanceof ShadowRoot) {
                buttonOptions.buttonRootNode = rootNode;
            }
            // pre-create button
            const button = this.client.createButton(buttonOptions);
            this.setClassName(element, [element.className, 'not-ready']);
            element.appendChild(button);
            let showButton = false;
            let readyToPay;
            try {
                readyToPay = yield this.client.isReadyToPay(this.createIsReadyToPayRequest(this.config));
                showButton =
                    (readyToPay.result && !this.config.existingPaymentMethodRequired)
                        || (readyToPay.result && readyToPay.paymentMethodPresent && this.config.existingPaymentMethodRequired)
                        || false;
            }
            catch (err) {
                console.error(err);
            }
            if (!this.isMounted())
                return;
            if (showButton) {
                try {
                    this.client.prefetchPaymentData(this.createLoadPaymentDataRequest(this.config));
                }
                catch (err) {
                    console.log('Error with prefetch', err);
                }
                // remove hidden className
                this.setClassName(element, (element.className || '').split(' ').filter(className => className && className !== 'not-ready'));
            }
            if (this.isReadyToPay !== (readyToPay === null || readyToPay === void 0 ? void 0 : readyToPay.result) || this.paymentMethodPresent !== (readyToPay === null || readyToPay === void 0 ? void 0 : readyToPay.paymentMethodPresent)) {
                this.isReadyToPay = !!(readyToPay === null || readyToPay === void 0 ? void 0 : readyToPay.result);
                this.paymentMethodPresent = readyToPay === null || readyToPay === void 0 ? void 0 : readyToPay.paymentMethodPresent;
                if (this.config.onReadyToPayChange) {
                    const readyToPayResponse = {
                        isButtonVisible: showButton,
                        isReadyToPay: this.isReadyToPay,
                    };
                    if (this.paymentMethodPresent) {
                        readyToPayResponse.paymentMethodPresent = this.paymentMethodPresent;
                    }
                    this.config.onReadyToPayChange(readyToPayResponse);
                }
            }
        });
    }
    setClassName(element, classNames) {
        const className = classNames.filter(name => name).join(' ');
        if (className) {
            element.className = className;
        }
        else {
            element.removeAttribute('class');
        }
    }
    appendStyles() {
        var _a, _b;
        if (typeof document === 'undefined')
            return;
        const rootNode = (_a = this.element) === null || _a === void 0 ? void 0 : _a.getRootNode();
        const styleId = `default-google-style-${this.options.cssSelector.replace(/[^\w-]+/g, '')}`;
        // initialize styles if rendering on the client:
        if (rootNode) {
            if (!((_b = rootNode.getElementById) === null || _b === void 0 ? void 0 : _b.call(rootNode, styleId))) {
                const style = document.createElement('style');
                style.id = styleId;
                style.type = 'text/css';
                style.innerHTML = `
          ${this.options.cssSelector} {
            display: inline-block;
          }
          ${this.options.cssSelector}.not-ready {
            width: 0;
            height: 0;
            overflow: hidden;
          }
        `;
                if (rootNode instanceof Document && rootNode.head) {
                    rootNode.head.appendChild(style);
                }
                else {
                    rootNode.appendChild(style);
                }
            }
        }
    }
    isClientInvalidated(newConfig) {
        if (!this.oldInvalidationValues)
            return true;
        const newValues = this.getInvalidationValues(newConfig);
        return newValues.some((value, index) => value !== this.oldInvalidationValues[index]);
    }
    getInvalidationValues(config) {
        var _a, _b;
        return [
            config.environment,
            config.existingPaymentMethodRequired,
            !!config.onPaymentDataChanged,
            !!config.onPaymentAuthorized,
            config.buttonColor,
            config.buttonType,
            config.buttonSizeMode,
            config.paymentRequest.merchantInfo.merchantId,
            config.paymentRequest.merchantInfo.merchantName,
            (_a = config.paymentRequest.merchantInfo.softwareInfo) === null || _a === void 0 ? void 0 : _a.id,
            (_b = config.paymentRequest.merchantInfo.softwareInfo) === null || _b === void 0 ? void 0 : _b.version,
        ];
    }
}

var name = "@google-pay/button-angular";
var version = "2.1.5";
var description = "Angular component for Google Pay button";
var main = "dist/index.js";
var repository = {
	type: "git",
	url: "https://github.com/google-pay/google-pay-button",
	directory: "src/button-angular"
};
var homepage = "https://github.com/google-pay/google-pay-button/tree/main/src/button-angular#readme";
var engines = {
	node: ">=8.0.0"
};
var author = "socsieng@google.com";
var license = "Apache-2.0";
var scripts = {
	build: "ng build --prod"
};
var dependencies = {
	"@types/googlepay": "^0.5.1"
};
var peerDependencies = {
	"@angular/core": ">=8.0.0",
	"@types/googlepay": "^0.5.1"
};
var files = [
	"dist/*",
	"bundles/*",
	"ems2015/*",
	"fesm2015/*",
	"lib/*",
	"button-angular/*",
	"google-pay-button-angular.*",
	"*.d.ts",
	"*.json",
	"README.md"
];
var keywords = [
	"googlepay",
	"google-pay",
	"google-pay-button",
	"button",
	"angular"
];
var devDependencies = {
	"@angular-devkit/build-ng-packagr": "^0.1002.0",
	"@angular/core": "^10.2.2",
	"ng-packagr": "^10.1.2"
};
var _package = {
	name: name,
	version: version,
	description: description,
	main: main,
	repository: repository,
	homepage: homepage,
	engines: engines,
	author: author,
	license: license,
	scripts: scripts,
	dependencies: dependencies,
	peerDependencies: peerDependencies,
	files: files,
	keywords: keywords,
	devDependencies: devDependencies
};

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a new function that delays invocations to the original function
 * within a specified wait period. The last invocation within this time period
 * gets invoked. All earlier invocations are ignore.
 *
 * @param func The function to invoke.
 * @param wait The time in milliseconds to wait for idle invocations.
 */
function debounce(func, wait = 0) {
    let timeout;
    return function (...args) {
        window.clearTimeout(timeout);
        const later = function () {
            timeout = undefined;
            return func(...args);
        };
        return new Promise(resolve => {
            timeout = window.setTimeout(() => {
                const result = later();
                resolve(result);
            }, wait);
        });
    };
}

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GooglePayButtonComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.manager = new ButtonManager({
            cssSelector: 'google-pay-button',
            softwareInfoId: name,
            softwareInfoVersion: version,
        });
        this.initializeButton = debounce(() => {
            if (!this.assertRequiredProperty('paymentRequest')) {
                return;
            }
            if (!this.assertRequiredProperty('environment')) {
                return;
            }
            const config = {
                paymentRequest: this.paymentRequest,
                environment: this.environment,
                existingPaymentMethodRequired: this.existingPaymentMethodRequired,
                onPaymentDataChanged: this.paymentDataChangedCallback,
                onPaymentAuthorized: this.paymentAuthorizedCallback,
                buttonColor: this.buttonColor,
                buttonType: this.buttonType,
                buttonSizeMode: this.buttonSizeMode,
                onReadyToPayChange: result => {
                    if (this.readyToPayChangeCallback) {
                        this.readyToPayChangeCallback(result);
                    }
                    this.dispatch('readytopaychange', result);
                },
                onCancel: reason => {
                    if (this.cancelCallback) {
                        this.cancelCallback(reason);
                    }
                    this.dispatch('cancel', reason);
                },
                onError: error => {
                    var _a;
                    if (this.errorCallback) {
                        (_a = this.errorCallback) === null || _a === void 0 ? void 0 : _a.call(this, error);
                    }
                    this.elementRef.nativeElement.dispatchEvent(new ErrorEvent('error', { error }));
                },
                onLoadPaymentData: paymentData => {
                    if (this.loadPaymentDataCallback) {
                        this.loadPaymentDataCallback(paymentData);
                    }
                    this.dispatch('loadpaymentdata', paymentData);
                },
            };
            this.manager.configure(config);
        });
    }
    get isReadyToPay() {
        return this.manager.isReadyToPay;
    }
    ngOnInit() {
        return this.manager.mount(this.elementRef.nativeElement);
    }
    ngOnChanges() {
        return this.initializeButton();
    }
    assertRequiredProperty(name) {
        const value = this[name];
        if (value === null || value === undefined) {
            this.throwError(Error(`Required property not set: ${name}`));
            return false;
        }
        return true;
    }
    /**
     * Throws an error.
     *
     * Used for testing purposes so that the method can be spied on.
     */
    throwError(error) {
        throw error;
    }
    dispatch(type, detail) {
        this.elementRef.nativeElement.dispatchEvent(new CustomEvent(type, {
            bubbles: true,
            cancelable: false,
            detail,
        }));
    }
}
GooglePayButtonComponent.decorators = [
    { type: Directive, args: [{
                selector: 'google-pay-button',
            },] }
];
GooglePayButtonComponent.ctorParameters = () => [
    { type: ElementRef }
];
GooglePayButtonComponent.propDecorators = {
    paymentRequest: [{ type: Input }],
    environment: [{ type: Input }],
    existingPaymentMethodRequired: [{ type: Input }],
    buttonColor: [{ type: Input }],
    buttonType: [{ type: Input }],
    buttonSizeMode: [{ type: Input }],
    paymentDataChangedCallback: [{ type: Input }],
    paymentAuthorizedCallback: [{ type: Input }],
    readyToPayChangeCallback: [{ type: Input }],
    loadPaymentDataCallback: [{ type: Input }],
    cancelCallback: [{ type: Input }],
    errorCallback: [{ type: Input }]
};

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GooglePayButtonModule {
}
GooglePayButtonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [GooglePayButtonComponent],
                imports: [],
                exports: [GooglePayButtonComponent],
            },] }
];

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { GooglePayButtonComponent, GooglePayButtonModule };
//# sourceMappingURL=google-pay-button-angular.js.map
